import { ethers } from 'ethers';
import { ArbitrageOpportunity, ExecutionResult, FlashLoanParams } from '../types/arbitrage.types';
import { NetworkConfig } from '../types/config.types';
import { logger } from '../utils/logger';

// Import the Arbitrage contract ABI (will be generated by typechain)
const ARBITRAGE_ABI = [
  'function executeAaveFlashLoan(address token, uint256 amount, address buyDex, address sellDex) external',
  'function executeBalancerFlashLoan(address token, uint256 amount, address buyDex, address sellDex) external',
  'function withdrawProfits(address token) external',
  'function setDEXApproval(address dex, bool approved) external',
  'function pause() external',
  'function unpause() external',
  'function paused() external view returns (bool)',
  'event ArbitrageExecuted(address indexed token, uint256 amount, uint256 profit, address indexed buyDex, address indexed sellDex, address WETH)',
];

/**
 * ContractInteractor - Handles all interactions with the Arbitrage smart contract
 */
export class ContractInteractor {
  private contract: ethers.Contract;
  private signer: ethers.Signer;
  private config: NetworkConfig;

  constructor(config: NetworkConfig, signer: ethers.Signer) {
    this.config = config;
    this.signer = signer;
    this.contract = new ethers.Contract(
      config.arbitrageContract,
      ARBITRAGE_ABI,
      signer
    );
  }

  /**
   * Execute arbitrage using Aave flash loan
   */
  async executeAaveArbitrage(
    opportunity: ArbitrageOpportunity,
    amount: ethers.BigNumber
  ): Promise<ExecutionResult> {
    const startTime = Date.now();

    try {
      logger.info('Executing Aave flash loan arbitrage', {
        tokenIn: opportunity.tokenIn,
        tokenOut: opportunity.tokenOut,
        amount: ethers.utils.formatEther(amount),
        buyDex: opportunity.buyDex,
        sellDex: opportunity.sellDex,
      });

      // Execute the transaction
      const tx = await this.contract.executeAaveFlashLoan(
        opportunity.tokenIn,
        amount,
        this.getDexRouterAddress(opportunity.buyDex),
        this.getDexRouterAddress(opportunity.sellDex)
      );

      logger.info('Transaction submitted', {
        hash: tx.hash,
        nonce: tx.nonce,
      });

      // Wait for confirmation
      const receipt = await tx.wait(this.config.execution.confirmations);

      logger.info('Transaction confirmed', {
        hash: receipt.transactionHash,
        gasUsed: receipt.gasUsed.toString(),
        status: receipt.status,
      });

      // Parse events to get profit
      const profit = this.parseArbitrageEvent(receipt);

      const executionTime = Date.now() - startTime;

      return {
        success: receipt.status === 1,
        transactionHash: receipt.transactionHash,
        profit,
        gasUsed: receipt.gasUsed,
        opportunity,
        executionTime,
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      logger.error('Arbitrage execution failed', {
        error: errorMessage,
        opportunity,
      });

      return {
        success: false,
        error: errorMessage,
        opportunity,
        executionTime,
      };
    }
  }

  /**
   * Execute arbitrage using Balancer flash loan
   */
  async executeBalancerArbitrage(
    opportunity: ArbitrageOpportunity,
    amount: ethers.BigNumber
  ): Promise<ExecutionResult> {
    const startTime = Date.now();

    try {
      logger.info('Executing Balancer flash loan arbitrage', {
        tokenIn: opportunity.tokenIn,
        tokenOut: opportunity.tokenOut,
        amount: ethers.utils.formatEther(amount),
        buyDex: opportunity.buyDex,
        sellDex: opportunity.sellDex,
      });

      // Execute the transaction
      const tx = await this.contract.executeBalancerFlashLoan(
        opportunity.tokenIn,
        amount,
        this.getDexRouterAddress(opportunity.buyDex),
        this.getDexRouterAddress(opportunity.sellDex)
      );

      logger.info('Transaction submitted', {
        hash: tx.hash,
        nonce: tx.nonce,
      });

      // Wait for confirmation
      const receipt = await tx.wait(this.config.execution.confirmations);

      logger.info('Transaction confirmed', {
        hash: receipt.transactionHash,
        gasUsed: receipt.gasUsed.toString(),
        status: receipt.status,
      });

      // Parse events to get profit
      const profit = this.parseArbitrageEvent(receipt);

      const executionTime = Date.now() - startTime;

      return {
        success: receipt.status === 1,
        transactionHash: receipt.transactionHash,
        profit,
        gasUsed: receipt.gasUsed,
        opportunity,
        executionTime,
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      logger.error('Arbitrage execution failed', {
        error: errorMessage,
        opportunity,
      });

      return {
        success: false,
        error: errorMessage,
        opportunity,
        executionTime,
      };
    }
  }

  /**
   * Simulate arbitrage execution (without actually sending transaction)
   */
  async simulateExecution(
    flashLoanParams: FlashLoanParams
  ): Promise<{ success: boolean; gasEstimate?: ethers.BigNumber; error?: string }> {
    try {
      let gasEstimate: ethers.BigNumber;

      if (flashLoanParams.provider === 'aave') {
        gasEstimate = await this.contract.estimateGas.executeAaveFlashLoan(
          flashLoanParams.token,
          flashLoanParams.amount,
          this.getDexRouterAddress(flashLoanParams.buyDex),
          this.getDexRouterAddress(flashLoanParams.sellDex)
        );
      } else {
        gasEstimate = await this.contract.estimateGas.executeBalancerFlashLoan(
          flashLoanParams.token,
          flashLoanParams.amount,
          this.getDexRouterAddress(flashLoanParams.buyDex),
          this.getDexRouterAddress(flashLoanParams.sellDex)
        );
      }

      logger.debug('Simulation successful', {
        gasEstimate: gasEstimate.toString(),
        provider: flashLoanParams.provider,
      });

      return { success: true, gasEstimate };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      logger.warn('Simulation failed', {
        error: errorMessage,
        params: flashLoanParams,
      });

      return { success: false, error: errorMessage };
    }
  }

  /**
   * Withdraw profits from the contract
   */
  async withdrawProfits(tokenAddress: string): Promise<ethers.providers.TransactionReceipt> {
    try {
      logger.info('Withdrawing profits', { token: tokenAddress });

      const tx = await this.contract.withdrawProfits(tokenAddress);
      const receipt = await tx.wait();

      logger.info('Profits withdrawn', {
        hash: receipt.transactionHash,
        gasUsed: receipt.gasUsed.toString(),
      });

      return receipt;
    } catch (error) {
      logger.error('Failed to withdraw profits', {
        token: tokenAddress,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Check contract balance for a token
   */
  async getContractBalance(tokenAddress: string): Promise<ethers.BigNumber> {
    try {
      const tokenContract = new ethers.Contract(
        tokenAddress,
        ['function balanceOf(address) external view returns (uint256)'],
        this.signer
      );

      const balance = await tokenContract.balanceOf(this.config.arbitrageContract);
      return balance;
    } catch (error) {
      logger.error('Failed to get contract balance', {
        token: tokenAddress,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Pause the contract
   */
  async pauseContract(): Promise<ethers.providers.TransactionReceipt> {
    try {
      logger.warn('Pausing contract');
      const tx = await this.contract.pause();
      const receipt = await tx.wait();
      
      logger.info('Contract paused', { hash: receipt.transactionHash });
      return receipt;
    } catch (error) {
      logger.error('Failed to pause contract', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Unpause the contract
   */
  async unpauseContract(): Promise<ethers.providers.TransactionReceipt> {
    try {
      logger.info('Unpausing contract');
      const tx = await this.contract.unpause();
      const receipt = await tx.wait();
      
      logger.info('Contract unpaused', { hash: receipt.transactionHash });
      return receipt;
    } catch (error) {
      logger.error('Failed to unpause contract', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Check if contract is paused
   */
  async isPaused(): Promise<boolean> {
    try {
      return await this.contract.paused();
    } catch (error) {
      logger.error('Failed to check pause status', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Approve a DEX for trading
   */
  async approveDex(dexAddress: string, approved: boolean): Promise<ethers.providers.TransactionReceipt> {
    try {
      logger.info('Setting DEX approval', { dex: dexAddress, approved });
      
      const tx = await this.contract.setDEXApproval(dexAddress, approved);
      const receipt = await tx.wait();
      
      logger.info('DEX approval set', { hash: receipt.transactionHash });
      return receipt;
    } catch (error) {
      logger.error('Failed to set DEX approval', {
        dex: dexAddress,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Parse ArbitrageExecuted event to extract profit
   */
  private parseArbitrageEvent(receipt: ethers.providers.TransactionReceipt): ethers.BigNumber | undefined {
    try {
      const arbitrageInterface = new ethers.utils.Interface(ARBITRAGE_ABI);
      
      for (const log of receipt.logs) {
        try {
          const parsed = arbitrageInterface.parseLog(log);
          if (parsed.name === 'ArbitrageExecuted') {
            return parsed.args.profit;
          }
        } catch {
          // Not our event, continue
          continue;
        }
      }
    } catch (error) {
      logger.warn('Failed to parse arbitrage event', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
    return undefined;
  }

  /**
   * Get DEX router address from name
   */
  private getDexRouterAddress(dexName: string): string {
    const dex = Object.values(this.config.dexes).find((d) => d?.name === dexName);
    if (!dex) {
      throw new Error(`DEX not found: ${dexName}`);
    }
    return dex.router;
  }

  /**
   * Get contract address
   */
  public getContractAddress(): string {
    return this.config.arbitrageContract;
  }
}